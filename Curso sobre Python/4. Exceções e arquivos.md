Este curso √© de propriedade do aplicativo [SoloLearn](https://play.google.com/store/apps/details?id=com.sololearn) e foi traduzido por [Ana Beatriz Augusto](https://www.linkedin.com/in/anabeatrizz) usando os recursos [Reverso Context](https://context.reverso.net/translation/) e [Google Tradutor](https://translate.google.com.br/?hl=pt-BR)

# √çndice
- [Exce√ß√µes](#exce√ß√µes)
- [Tratando exce√ß√µes](#tratando-exce√ß√µes)
- [finally](#finally)
- [Chamando exce√ß√µes](#chamando-exce√ß√µes)
- [Asser√ß√µes](#asser√ß√µes)
- [Abrindo arquivos](#abrindo-arquivos)
- [Lendo arquivos](#lendo-arquivos)
- [Escrevendo em arquivos](#escrevendo-em-arquivos)
- [Trabalhando com arquivos](#trabalhando-com-arquivos)

# [Exce√ß√µes](#√≠ndice)
N√≥s j√° vimos __exce√ß√µes__ em c√≥digos anteriores. Ocorrem quando algo d√° errado, devido a c√≥digo incorreto ou entrada incorreta. Quando uma exce√ß√£o ocorre, o programa para imediatamente.<br>O seguinte c√≥digo produz a exce√ß√£o `ZeroDivisionError` quando se tenta dividir 7 por 0.
```python
num1 = 7
num2 = 0
print(num1 / num2)
```

__Resultado:__
```python
>>>
ZeroDivisionError: division by zero
>>>
```

Diferentes exce√ß√µes s√£o criadas por diferentes motivos.<br>Exce√ß√µes comuns:<br>`ImportError`: falha na importa√ß√£o;<br>`IndexError`: uma lista est√° indexada com um numero fora do intervalo;<br>`NameError`: uma vari√°vel desconhecida √© usada;<br>`SyntaxError`: o c√≥digo n√£o pode ser analisado corretamente;<br>`TypeError`: uma fun√ß√£o √© chamada em um valor de tipo inapropriado;<br>`ValueError`: uma fun√ß√£o √© chamada em um valor de tipo correto, mas com um valor inapropriado.

O Python tem v√°rias outras exce√ß√µes embutidas, como `ZeroDivisionError` e `OSError`. Bibliotecas de terceiros frequentemente tamb√©m definem suas proprias exce√ß√µes.

# [Tratando exce√ß√µes](#√≠ndices)
Para se trata exce√ß√µes e chama c√≥digo quando uma exce√ß√£o ocorre, voc√™ pode usar `try`/`except`.<br>O bloco `try` cont√©m c√≥digo onde talvez ocorra uma exce√ß√£o. Se essa exce√ß√£o ocorrer, o c√≥digo dentro do bloco `try` para de ser executado e o c√≥digo no bloco `except` √© executado. Se nenhum erro ocorrer, o c√≥digo no bloco `except` n√£o se executa.<br>__Por exemplo:__
```python
try:
   num1 = 7
   num2 = 0
   print(num1 / num2)
   print("C√°lculo feito")
except ZeroDivisionError:
   print("Um erro ocorreu")
   print("devido pela divis√£o por zero")
```

__Resultado:__
```python
>>>
Um erro ocorreu
devido pela divis√£o por zero
>>>
```

No c√≥digo acima, o `except` define o tipo de exce√ß√£o para se tratar (neste caso, `ZeroDivisionError`).

Um `try` pode ter v√°rios blocos `except` diferentes para tratar diferentes exce√ß√µes.<br>Multiplas exce√ß√µes tamb√©m podem ser colocadas em um unico bloco `except` usando parenteses, para o bloco `except` tratar todas elas.
```python
try:
   variavel = 10
   print(variavel + "ol√°")
   print(variavel / 2)
except ZeroDivisionError:
   print("Dividido por zero")
except (ValueError, TypeError):
   print("Um erro ocorreu")
```

__Resultado:__
```python
>>>
Um erro ocorreu
>>>
```

Um `except` sem qualquer exce√ß√£o especificada ir√° pegar todos os erros. Estes devem ser usados moderadamente, pois eles podem pegar erros inesperados e esconder erros de programa√ß√£o.<br>__Por exemplo:__
```python
try:
   palavra = "spam"
   print(palavra / 0)
except:
   print("Um erro ocorreu")
```

__Resultado:__
```python
>>>
Um erro ocorreu
>>>
```

Tratar exce√ß√µes √© particularmente util quando se lida com entrada de usu√°rio.

# [finally](#√≠ndice)
Para ter certeza que algum c√≥digo ir√° ser executado n√£o importando qual erro aconte√ßa, voc√™ pode usar `finally`. Ele √© colocado no fim de `try`/`except`. C√≥digo dentro de um `finally` sempre se executa depois da execu√ß√£o do c√≥digo no bloco `try` e possivelmente do bloco `except`.
```python
try:
   print("Ol√°")
   print(1 / 0)
except ZeroDivisionError:
   print("Dividido por zero")
finally:
   print("Este c√≥digo ser√° exectado n√£o importando o que aconte√ßa")
```

__Resultado:__
```python
>>>
Ol√°
Dividido por zero
Este c√≥digo ser√° exectado n√£o importando o que aconte√ßa
>>>
```

C√≥digo dentro de um `finally` se executa at√© mesmo quando uma exce√ß√£o n√£o pega ocorrer em um dos blocos anteriores.
```python
try:
   print(1)
   print(10 / 0)
except ZeroDivisionError:
   print(variavel_desconhecida)
finally:
   print("Isso √© executado por ultimo")
```

__Resultado:__
```python
>>>
1
Isso √© executado por ultimo

ZeroDivisionError: division by zero
During handling of the above exception, another exception occurred:
NameError: name 'unknown_var' is not defined
>>>
```

# [Chamando exce√ß√µes](#√≠ndice)
Voc√™ pode chamar exce√ß√µes usando `raise`.
```python
print(1)
raise ValueError
print(2)
```

__Resultado:__
```python
>>>
1
ValueError
>>>
```

Voc√™ precisa especificar o __tipo__ de exce√ß√£o que deseja chamar.

Exce√ß√µes podem ser chamadas com argumentos que d√£o detalhes sobre elas.<br>__Por exemplo:__
```python
nome = "123"
raise NameError("Nome inv√°lido!")
```

__Resultado:__
```python
>>>
NameError: Nome inv√°lido!
>>>
```

Em blocos `except`, o `raise` pode ser usado sem argumentos para chamar novamente qualquer exce√ß√£o que acontecer.<br>__Por exemplo:__
```python
try:
   num = 5 / 0
except:
   print("Um erro ocorreu")
   raise
```

__Resultado:__
```python
>>>
Um erro ocorreu

ZeroDivisionError: division by zero
>>>
```

# [Asser√ß√µes](#√≠ndice)
Uma __asser√ß√£o__ √© uma verifica√ß√£o de normalidade que voc√™ pode ligar ou desligar quando terminar de testar seu programa.<br>Uma express√£o √© testada e se o resultado for falso, uma exce√ß√£o √© chamada.<br>Asser√ß√µes s√£o executadas atrav√©s do uso de `assert`.
```python
print(1)
assert 2 + 2 == 4
print(2)
assert 1 + 1 == 3
print(3)
```

__Resultado:__
```python
>>>
1
2
AssertionError
>>>
```

Programadores frequentemente colocam asser√ß√µes no come√ßo de uma fun√ß√£o para verificar entradas e depois de uma chamada de fun√ß√£o para verificar sa√≠das.

`assert` pode levar um segundo argumento que √© passado ao AssertionError, chamado quando a asser√ß√£o falha.
```python
temp = -10
assert (temp >= 0), "Mais frio que zero absoluto!"
```

__Resultado:__
```python
>>>
AssertionError: Mais frio que zero absoluto!
>>>
```

Exce√ß√µes AssertionError podem ser pegas e tratadas como qualquer outra exce√ß√£o usando `try`/`except`, mas se n√£o tratadas, este tipo de exce√ß√£o ir√° terminar o programa.

# [Abrindo arquivos](#√≠ndice)
Voc√™ pode usar Python para ler e escrever o conte√∫do de __arquivos__.<br>Arquivos de texto s√£o os mais f√°ceis de manipular. Antes de poder editar um arquivo, ele deve estar aberto usando a fun√ß√£o `open`.
```python
meuarquivo = open("nomedoarquivo.txt")
```

O argumento da fun√ß√£o `open` √© o __caminho__ do arquivo. Se o arquivo est√° no mesmo diret√≥rio do programa, voc√™ pode especificar apenas seu nome.

Voc√™ pode especificar o __modo__ usado para abrir um arquivo aplicando um segundo argumento √† fun√ß√£o `open`.<br>`r` significa abrir em modo de leitura, que √© o padr√£o.<br>`w` significa modo de escrita, para reescrever o conte√∫do de um arquivo.<br>`a` significa modo de adi√ß√£o, para adicionar novo conte√∫do no fim do arquivo.

Adicionar `b` √† um modo, abre o arquivo em modo __bin√°rio__, que √© usado para arquivos n√£o textuais (como imagens e arquivos de som).<br>__Por exemplo:__
```python
# modo de escrita
open("nomedoarquivo.txt", "w")

# modo de leitura
open("nomedoarquivo.txt", "r")
open("nomedoarquivo.txt")

# modo de escrita bin√°ria
open("nomedoarquivo.txt", "wb")
```

Voc√™ pode usar o sinal `+` com cada modo acima para dar um acesso extra aos arquivos. Por exemplo, `r+` abre o arquivo para leitura e escrita.

Uma vez que o arquivo foi aberto e usado, voc√™ deve fech√°-lo.<br>Isso √© feito usando o m√©todo `close` do objeto do arquivo.
```python
arquivo = open("nomedoarquivo.txt", "w")
# fa√ßa algo com o arquivo
arquivo.close()
```

## üö∏ Este arquivo est√° em processo de finaliza√ß√£o
