# üö∏ Esta parte do curso est√° em progresso

Este curso √© de propriedade do aplicativo [SoloLearn](https://play.google.com/store/apps/details?id=com.sololearn) e foi traduzido por [Ana Beatriz Augusto](https://www.linkedin.com/in/anabeatrizz) usando os recursos [Reverso Context](https://context.reverso.net/translation/) e [Google Tradutor](https://translate.google.com.br/?hl=pt-BR)

# √çndice
- [Programa√ß√£o Funcional](#programa√ß√£o-funcional)
   - [Fun√ß√µes puras](#fun√ß√µes-puras)
- [Lambdas](#lambdas)
- [map e filter](#map-e-filter)
   - [map](#map)
   - [filter](#filter)
- [Geradores](#geradores)
- [Decoradores](#decoradores)
- [Recurs√£o](#recurs√£o)
- [Sets](#sets)
- [itertools](#itertools)

# [Programa√ß√£o Funcional](#√≠ndice)
A programa√ß√£o funcional √© um estilo de programa√ß√£o que (como o nome sugere) √© baseado em fun√ß√µes.<br>Uma parte chave da programa√ß√£o funcional s√£o as fun√ß√µes de ordem superior. Vimos essa ideia de maneira resumida quando falamos sobre fun√ß√µes como objetos. Fun√ß√µes de ordem superior levam outras fun√ß√µes como argumentos, ou as retornam como resultado.<br>__Exemplo:__

```python
def aplique_duas_vezes(funcao, arg):
   return funcao(funcao(arg))

def adicione_cinco(x):
   return x + 5

print(aplique_duas_vezes(adicione_cinco, 10))
```

__Resultado:__

```python
>>>
20
>>>
```

A fun√ß√£o `aplique_duas_vezes` leva outra fun√ß√£o como seu argumento e a chama duas vezes.

### [Fun√ß√µes puras](#√≠ndice)
A programa√ß√£o funcional procura usar __fun√ß√µes puras__. Fun√ß√µes puras n√£o tem efeitos colaterais e retornam um valor que depende __apenas__ de seus argumentos.<br>As fun√ß√µes na matem√°tica funcionam assim: por exemplo, cos(x) ir√°, para o mesmo valor de x, sempre retornar o mesmo resultado.<br>Abaixo est√£o alguns exemplos de fun√ß√µes puras e impuras.<br>__Fun√ß√£o pura__

```python
def funcao_pura(x, y):
  temp = x + 2 * y
  return temp / (2 * x + y)
```

__Fun√ß√£o impura__

```python
alguma_lista = []

def impura(arg):
  alguma_lista.append(arg)
```

A fun√ß√£o acima n√£o √© pura, pois muda o estado de `alguma_lista`

Usar fun√ß√µes puras tem seu lado bom e ruim.<br>Fun√ß√µes puras s√£o:
- mais f√°ceis de raciocinar e testar
- mais eficientes. Uma vez que a fun√ß√£o tem uma entrada, o resultado pode ser armazenado e referenciado na pr√≥xima vez em que for necess√°rio, reduzindo a chamada a essa fun√ß√£o. Isso √© chamado de __memoization__.
- mais f√°ceis de executar em paralelo

A principal desvantagem de usar apenas fun√ß√µes puras √© que elas complicam principalmente a tarefa simples do I/O, pois isso parece exigir inerentemente efeitos colaterais.<br>Elas tamb√©m podem ser mais dif√≠ceis de escrever em algumas situa√ß√µes.

# [Lambdas](#√≠ndice)
Criar uma fun√ß√£o normalmente (usando `def`) a atribu√≠ √† uma vari√°vel automaticamente.<br>Isso √© diferente da cria√ß√£o de outros objetos ‚Äì como strings e n√∫meros inteiros ‚Äì que podem ser escritos direto, sem a atribui√ß√£o a uma vari√°vel.<br>O mesmo √© poss√≠vel com fun√ß√µes contanto que sejam criadas usando a sintaxe lambda.<br>Fun√ß√µes criadas dessa maneira s√£o conhecidas como __an√¥nimas__.<br>Essa abordagem √© comumente usada quando se passa uma simples fun√ß√£o como argumento a outra fun√ß√£o. A sintaxe √© mostrada no pr√≥ximo exemplo e consiste da palavra reservada `lambda` seguida por uma lista de argumentos, dois pontos e a express√£o a ser avaliada e retornada.

```python
def minha_funcao(f, arg):
  return f(arg)

minha_funcao(lambda x: 2*x*x, 5)
```

Fun√ß√µes lambda receberam esse nome por causa do c√°lculo lambda que √© um modelo computacional inventado por Alonzo Church.

As fun√ß√µes lambda n√£o s√£o t√£o poderosas quanto fun√ß√µes nomeadas.<br>Apenas podem fazer coisas que requerem uma √∫nica express√£o ‚Äì geralmente equivalentes a uma √∫nica linha de c√≥digo.<br>__Exemplo:__

```python
#fun√ß√£o nomeada
def polinomial(x):
    return x**2 + 5*x + 4
print(polinomial(-4))

#lambda
print((lambda x: x**2 + 5*x + 4) (-4))
```

__Resultado:__

```python
>>>
0
0
>>>
```

No c√≥digo acima, criamos uma fun√ß√£o an√¥nima direto e a usamos como argumento.

Fun√ß√µes lambda podem ser atribu√≠das a vari√°veis e usadas como fun√ß√µes normais.<br>__Exemplo:__

```python
dobro = lambda x: x * 2
print(dobro(7))
```

__Resultado:__

```python
>>>
14
>>>
```

Por√©m, raramente h√° uma boa raz√£o para fazer isso ‚Äì geralmente √© melhor definir uma fun√ß√£o com `def`

# [map e filter](#√≠ndice)
### [map](#√≠ndice)
As fun√ß√µes embutidas `map` e `filter` s√£o  fun√ß√µes de ordem superior √∫teis que operam em listas (ou objetos similares chamados de __iter√°veis__).<br>A fun√ß√£o `map` leva uma fun√ß√£o e um iter√°vel como argumentos e retorna um novo iter√°vel com a fun√ß√£o aplicada a cada argumento.<br>__Exemplo:__

```python
def adicione_cinco(x):
  return x + 5

nums = [11, 22, 33, 44, 55]
resultado = list(map(adicione_cinco, nums))
print(resultado)
```

__Resultado:__

```python
>>>
[16, 27, 38, 49, 60]
>>>
```

Podemos ter tido o mesmo resultado facilmente usando a sintaxe lambda.

```python
nums = [11, 22, 33, 44, 55]

resultado = list(map(lambda x: x+5, nums))
print(resultado)
```

Para converter o resultado para uma lista, usamos `list` explicitamente.

### [filter](#√≠ndice)
A fun√ß√£o `filter` filtra um iter√°vel removendo itens que n√£o combinam com um predicado (uma fun√ß√£o que retorna um booleano).<br>__Exemplo:__

```python
nums = [11, 22, 33, 44, 55]
res = list(filter(lambda x: x%2==0, nums))
print(res)
```

__Resultado:__

```python
>>>
[22, 44]
>>>
```

Como `map`, o resultado precisa ser explicitamente convertido para uma lista se quiser mostr√°-lo.

# [Geradores](#√≠ndice)

# [Decoradores](#√≠ndice)

# [Recurs√£o](#√≠ndice)

# [Sets](#√≠ndice)

# [itertools](#√≠ndice)
