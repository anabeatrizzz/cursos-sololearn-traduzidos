# üö∏ Esta parte do curso est√° em progresso

Este curso √© de propriedade do aplicativo [SoloLearn](https://play.google.com/store/apps/details?id=com.sololearn) e foi traduzido por [Ana Beatriz Augusto](https://www.linkedin.com/in/anabeatrizz) usando os recursos [Reverso Context](https://context.reverso.net/translation/) e [Google Tradutor](https://translate.google.com.br/?hl=pt-BR)

# √çndice
- [Programa√ß√£o Funcional](#programa√ß√£o-funcional)
   - [Fun√ß√µes puras](#fun√ß√µes-puras)
- [Lambdas](#lambdas)
- [map e filter](#map-e-filter)
   - [map](#map)
   - [filter](#filter)
- [Geradores](#geradores)
- [Decoradores](#decoradores)
- [Recurs√£o](#recurs√£o)
- [Sets](#sets)
- [itertools](#itertools)

# [Programa√ß√£o Funcional](#√≠ndice)
A programa√ß√£o funcional √© um estilo de programa√ß√£o que (como o nome sugere) √© baseado em fun√ß√µes.<br>Uma parte chave da programa√ß√£o funcional s√£o as fun√ß√µes de ordem superior. Vimos essa ideia de maneira resumida quando falamos sobre fun√ß√µes como objetos. Fun√ß√µes de ordem superior levam outras fun√ß√µes como argumentos, ou as retornam como resultado.<br>__Exemplo:__

```python
def aplique_duas_vezes(funcao, arg):
   return funcao(funcao(arg))

def adicione_cinco(x):
   return x + 5

print(aplique_duas_vezes(adicione_cinco, 10))
```

__Resultado:__

```python
>>>
20
>>>
```

A fun√ß√£o `aplique_duas_vezes` leva outra fun√ß√£o como seu argumento e a chama duas vezes.

### [Fun√ß√µes puras](#√≠ndice)
A programa√ß√£o funcional procura usar __fun√ß√µes puras__. Fun√ß√µes puras n√£o tem efeitos colaterais e retornam um valor que depende __apenas__ de seus argumentos.<br>As fun√ß√µes na matem√°tica funcionam assim: por exemplo, cos(x) ir√°, para o mesmo valor de x, sempre retornar o mesmo resultado.<br>Abaixo est√£o alguns exemplos de fun√ß√µes puras e impuras.<br>__Fun√ß√£o pura__

```python
def funcao_pura(x, y):
  temp = x + 2 * y
  return temp / (2 * x + y)
```

__Fun√ß√£o impura__

```python
alguma_lista = []

def impura(arg):
  alguma_lista.append(arg)
```

A fun√ß√£o acima n√£o √© pura, pois muda o estado de `alguma_lista`

Usar fun√ß√µes puras tem seu lado bom e ruim.<br>Fun√ß√µes puras s√£o:
- mais f√°ceis de raciocinar e testar
- mais eficientes. Uma vez que a fun√ß√£o tem uma entrada, o resultado pode ser armazenado e referenciado na pr√≥xima vez em que for necess√°rio, reduzindo a chamada a essa fun√ß√£o. Isso √© chamado de __memoization__.
- mais f√°ceis de executar em paralelo

A principal desvantagem de usar apenas fun√ß√µes puras √© que elas complicam principalmente a tarefa simples do I/O, pois isso parece exigir inerentemente efeitos colaterais.<br>Elas tamb√©m podem ser mais dif√≠ceis de escrever em algumas situa√ß√µes.

# [Lambdas](#√≠ndice)
Criar uma fun√ß√£o normalmente (usando `def`) a atribu√≠ √† uma vari√°vel automaticamente.<br>Isso √© diferente da cria√ß√£o de outros objetos ‚Äì como strings e n√∫meros inteiros ‚Äì que podem ser escritos direto, sem a atribui√ß√£o a uma vari√°vel.<br>O mesmo √© poss√≠vel com fun√ß√µes contanto que sejam criadas usando a sintaxe lambda.<br>Fun√ß√µes criadas dessa maneira s√£o conhecidas como __an√¥nimas__.<br>Essa abordagem √© comumente usada quando se passa uma simples fun√ß√£o como argumento a outra fun√ß√£o. A sintaxe √© mostrada no pr√≥ximo exemplo e consiste da palavra reservada `lambda` seguida por uma lista de argumentos, dois pontos e a express√£o a ser avaliada e retornada.

```python
def minha_funcao(f, arg):
  return f(arg)

minha_funcao(lambda x: 2*x*x, 5)
```

Fun√ß√µes lambda receberam esse nome por causa do c√°lculo lambda que √© um modelo computacional inventado por Alonzo Church.

As fun√ß√µes lambda n√£o s√£o t√£o poderosas quanto fun√ß√µes nomeadas.<br>Apenas podem fazer coisas que requerem uma √∫nica express√£o ‚Äì geralmente equivalentes a uma √∫nica linha de c√≥digo.<br>__Exemplo:__

```python
#fun√ß√£o nomeada
def polinomial(x):
    return x**2 + 5*x + 4
print(polinomial(-4))

#lambda
print((lambda x: x**2 + 5*x + 4) (-4))
```

__Resultado:__

```python
>>>
0
0
>>>
```

No c√≥digo acima, criamos uma fun√ß√£o an√¥nima direto e a usamos como argumento.

Fun√ß√µes lambda podem ser atribu√≠das a vari√°veis e usadas como fun√ß√µes normais.<br>__Exemplo:__

```python
dobro = lambda x: x * 2
print(dobro(7))
```

__Resultado:__

```python
>>>
14
>>>
```

Por√©m, raramente h√° uma boa raz√£o para fazer isso ‚Äì geralmente √© melhor definir uma fun√ß√£o com `def`

# [map e filter](#√≠ndice)
### [map](#√≠ndice)
As fun√ß√µes embutidas `map` e `filter` s√£o  fun√ß√µes de ordem superior √∫teis que operam em listas (ou objetos similares chamados de __iter√°veis__).<br>A fun√ß√£o `map` leva uma fun√ß√£o e um iter√°vel como argumentos e retorna um novo iter√°vel com a fun√ß√£o aplicada a cada argumento.<br>__Exemplo:__

```python
def adicione_cinco(x):
  return x + 5

nums = [11, 22, 33, 44, 55]
resultado = list(map(adicione_cinco, nums))
print(resultado)
```

__Resultado:__

```python
>>>
[16, 27, 38, 49, 60]
>>>
```

Podemos ter tido o mesmo resultado facilmente usando a sintaxe lambda.

```python
nums = [11, 22, 33, 44, 55]

resultado = list(map(lambda x: x+5, nums))
print(resultado)
```

Para converter o resultado para uma lista, usamos `list` explicitamente.

### [filter](#√≠ndice)
A fun√ß√£o `filter` filtra um iter√°vel removendo itens que n√£o combinam com um predicado (uma fun√ß√£o que retorna um booleano).<br>__Exemplo:__

```python
nums = [11, 22, 33, 44, 55]
res = list(filter(lambda x: x%2==0, nums))
print(res)
```

__Resultado:__

```python
>>>
[22, 44]
>>>
```

Como `map`, o resultado precisa ser explicitamente convertido para uma lista se quiser mostr√°-lo.

# [Geradores](#√≠ndice)
__Geradores__ s√£o um tipo de iter√°vel, como listas ou tuplas.<br>Diferente das listas, n√£o permitem indexa√ß√£o com √≠ndices arbitr√°rios, mas ainda podem ser iterados atrav√©s de ciclos `for`.<br>Podem ser criados usando fun√ß√µes e com a palavra reservada `yield`.<br>__Exemplo:__

```python
def regressiva():
  i = 5
  while i > 0:
    yield i
    i -= 1
    
for i in regressiva():
  print(i)
```

__Resultado:__

```python
>>>
5
4    
3
2
1
```

O `yield` √© usado para definir um gerador, substitui o retorno de uma fun√ß√£o para fornecer um resultado a sua chamada sem destruir vari√°veis locais.

Devido ao fato de que geram um item por vez, os geradores n√£o tem restri√ß√µes de mem√≥ria como as listas.<br>Na verdade, podem ser __infinitos!__

```python
def sete_infinito():
  while True:
    yield 7
        
for i in sete_infinito():
  print(i)
```

__Resultado:__

```python
>>>
7
7
7
7
7
7
7
...
```

Resumindo, os __geradores__ te permitem declarar uma fun√ß√£o que se comporta como um iterador, isto √©, podem ser usadas em um ciclo `for`.

Geradores finitos podem ser convertidos para listas quando se usa eles como argumentos na fun√ß√£o `list`.

```python
def numeros(x):
  for i in range(x):
    if i % 2 == 0:
      yield i

print(list(numeros(11)))
```

__Resultado:__

```python
>>>
[0, 2, 4, 6, 8, 10]
>>>
```

Usar __geradores__ resulta em performance melhorada, que √© o resultado da pregui√ßosa gera√ß√£o de valores, que significa menos mem√≥ria sendo usada. Al√©m disso, n√£o precisamos esperar at√© que todos os elementos sejam gerados antes de come√ßarmos a us√°-los.

# [Decoradores](#√≠ndice)
__Decoradores__ fornecem uma forma de modificar fun√ß√µes usando outras fun√ß√µes.<br>Isso √© ideal quando voc√™ precisa extender a funcionalidade de fun√ß√µes que voc√™ n√£o quer modificar.<br>__Exemplo:__
```python
def decor(funcao):
  def wrap():
    print("============")
    funcao()
    print("============")
  return wrap

def mostre_texto():
  print("Ol√° mundo!")

decorado = decor(mostre_texto)
decorado()
```

Definimos uma fun√ß√£o nomeada `decor` que tem um unico parametro, `funcao`. Dentro de `decor`, definimos uma fun√ß√£o aninhada chamada de `wrap`. A fun√ß√£o `wrap` ir√° mostrar uma string, ent√£o ir√° chamar `funcao()` e mostrar outra string. A fun√ß√£o `decor` retorna a fun√ß√£o `wrap` como resultado.<br>Podemos dizer que a variavel `decorado` √© uma vers√£o decorada de `mostre_texto` - √© `mostre_texto` com algo mais.<br>De fato, se escrevemos um decorador util, talvez iriamos querer substituir `mostre_texto` pela vers√£o decorada totalmente, assim n√≥s sempre teriamos nossa vers√£o do `mostre_texto` "com algo mais".<br>Isso √© feito pela reatribui√ß√£o da variavel que contem nossa fun√ß√£o:
```python
mostre_texto = decor(mostre_texto)
mostre_texto()
```

Agora `mostre_texto` corresponde a nossa vers√£o decorada.

No exemplo anterior, decoramos nossa fun√ß√£o substituindo a variavel que continha a fun√ß√£o por uma vers√£o agrupada.
```python
def mostre_texto():
  print("Ol√° mundo!")

mostre_texto = decor(mostre_texto)
```

Esse padr√£o pode ser usado a qualquer momento, para agrupar qualquer fun√ß√£o.<br>O Python fornece apoio para agrupar uma fun√ß√£o em um decorador, colocando um nome de decorador antes da defini√ß√£o da fun√ß√£o usando @.<br>Se estamos definindo uma fun√ß√£o, podemos "decorar" ela com o @, como:
```python
@decor
def mostre_texto():
  print("Ol√° mundo!")
```

Este c√≥digo teria o mesmo resultado que o codigo anterior.

Uma unica fun√ß√£o pode ter multiplos decoradores.

# [Recurs√£o](#√≠ndice)
__Recurs√£o__ √© um conceito muito importante na programa√ß√£o funcional.<br>A parte fundamental da recurs√£o √© a auto referencia - fun√ß√µes chamando elas mesmas. Isso √© usado para resolver problemas que podem ser separados em sub problemas mais faceis do mesmo tipo.

Um exemplo classico de uma fun√ß√£o que √© implementada recursivamente √© a fun√ß√£o __fatorial__, que encontra o produto de todos os inteiros positivos que est√£o antes de um numero especificado.<br>Por exemplo, 5! (5 fatorial) √© 5 * 4 * 3 * 2 * 1 (120). Para implementar isso de maneira recursiva, note que 5! = 5 * 4!, 4! = 4 * 3!, 3! = 3 * 2! e assim em diante. Geralmente, n! = n * (n - 1)!.<br>Al√©m do mais, 1! = 1. Isso √© conhecido como o __caso base__, pois pode ser calculado sem fazer fatoriais adicionais.<br>Abaixo est√° uma implementa√ß√£o recursiva da fun√ß√£o fatorial.
```python
def fatorial(x):
  if x == 1:
    return 1
  else: 
    return x * fatorial(x-1)
    
print(fatorial(5))
```

__Resultado:__
```python
>>>
120
>>>
```

O __caso base__ age como a condi√ß√£o de saida da recurs√£o.

Fun√ß√µes recursivas podem ser infinitas, como os ciclos `while` infinitos. Isso frequentemente ocorre quando voc√™ esquece de implementar o caso baso.<br>Abaixo est√° uma vers√£o incorreta da fun√ß√£o fatorial. N√£o tem caso base, ent√£o ela executa at√© se esgotar a memoria.
```python
def fatorial(x):
  return x * fatorial(x-1)
    
print(factorial(5))
```

__Resultado:__
```python
>>>
RuntimeError: maximum recursion depth exceeded
>>>
```

A recurs√£o tambem pode ser indireta. Uma fun√ß√£o pode chamar uma segunda, que chama a primeira, que chama a segunda e assim em diante. Isso pode ocorrer com qualquer numero de fun√ß√µes.<br>__Exemplo:__
```python
def eh_par(x):
  if x == 0:
    return True
  else:
    return eh_impar(x-1)

def eh_impar(x):
  return not eh_par(x)


print(eh_impar(17))
print(eh_par(23))
```

__Resultado:__
```python
>>>
True
False
>>>
```

# [Sets](#√≠ndice)

# [itertools](#√≠ndice)
