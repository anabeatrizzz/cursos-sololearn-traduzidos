# Esta parte do curso está em processo de finalização

Este curso é de propriedade do aplicativo [SoloLearn](https://play.google.com/store/apps/details?id=com.sololearn) e foi traduzido por [Ana Beatriz Augusto](https://www.linkedin.com/in/anabeatrizz) usando os recursos [Reverso Context](https://context.reverso.net/translation/) e [Google Tradutor](https://translate.google.com.br/?hl=pt-BR)

# Índice
- [Classes](#classes)
   - [\_\_init_\_](#\_\_init_\_)
   - [Métodos](#métodos)
- [Herança](#herança)
- [Métodos mágicos e sobrecarga de operadores](#métodos-mágicos-e-sobrecarga-de-operadores)
- [Ciclo de vida de um objeto](#ciclo-de-vida-de-um-objeto)
- [Ocultando dados](#ocultando-dados)
- [Métodos class e static](#métodos-class-e-static)
- [Propriedades](#propriedades)
- [Um jogo simples](#um-jogo-simples)

# [Classes](#índice)
Anteriormente, vimos dois paradigmas da programação - __imperativa__ (usando comandos, ciclos e funções como sub rotinas) e __funcional__ (usando funções puras, funções de ordem superior e recursão).

Outro paradigma muito popular é a __programação orientada a objetos__ (POO).<br>Objetos são criados usando __classes__, que são, na verdade, o ponto foco da POO.<br>A __classe__ descreve o que o objeto será, mas é separada do objeto propriamente dito. Em outras palavras, uma classe pode ser descrita como a planta de um objeto, descrição ou definição.<br>Você pode usar a mesma classe como uma descrição para criar multiplos objetos diferentes.

Classes são criadas usando a palavra reservada `class` e um bloco indentado, que contem __métodos__ da classe (que são funções).<br>Abaixo está um exemplo de uma simples classe e seus objetos.
```python
class Gato:
  def __init__(self, cor, pernas):
    self.cor = cor
    self.pernas = pernas

felix = Gato("laranja", 4)
rover = Gato("dog-colored", 4)
stumpy = Gato("marrom", 3)
```

Este código define uma classe chamada __Gato__, que tem dois atributos: __cor__ e __pernas__.<br>Então, a classe é usada para criar 3 objetos separados dessa classe.

### [\_\_init_\_](#índice)
O método `__init__` é o metodo mais importante em uma classe.<br>Ele é chamado quando uma instancia (objeto) da classe é criada, usando o nome da classe como uma função.

Todos os metodos devem ter um `self` como primeiro parametro, embora não seja explicitamente passado, o Python adiciona o argumento `self` para você; você não precisa incluí-lo quando chama os metodos. Dentro da definição de um metodo, `self` se refere a instancia que chama o metodo.

Instancias de uma classe tem __atributos__, que são pedaços de dados que estão associados com elas.<br>Neste exemplo, as instancias de __Gato__ tem os atributos __cor__ e __pernas__. Podem ser acessados colocando um __ponto final__ e o nome do atributo depois da instancia.<br>Em um metodo `__init__`, __self.atributo__ pode, entretando, ser usado para definir o valor inicial dos atributos de uma instancia.<br>__Exemplo:__
```python
class Gato:
  def __init__(self, cor, pernas):
    self.cor = cor
    self.pernas = pernas

felix = Gato("laranja", 4)
print(felix.cor)
```

__Resultado:__
```python
>>>
laranja
>>>
```

No exemplo acima, o metodo `__init__` leva dois argumentos e atribui eles aos atributos do objeto. O metodo `__init__` é chamado de __construtor__ da classe.

### [Métodos](#índice)
Classes podem ter outros __métodos__ definidos para adicionar funcionalidades a elas.<br>Lembre-se que todos os métodos devem ter `self` como primeiro parametro.<br>Esses métodos são acessados usando a mesma sintaxe do __ponto final__ , como os atributos.<br>__Exemplo:__
```python
class Cachorro:
  def __init__(self, nome, cor):
    self.nome = nome
    self.cor = cor

  def latir(self):
    print("Au! Au!")

fido = Cachorro("Fido", "marrom")
print(fido.nome)
fido.latir()
```

__Resultado:__
```python
>>>
Fido
Au! Au!
>>>
```

Classes tambem podem ter __atributos de classe__, criados atribuindo variaveis dentro do corpo da classe. Podem ser acessados pelas instancias da classe, ou pela classe propriamente dita.<br>__Exemplo:__
```python
class Cachorro:
  pernas = 4
  def __init__(self, nome, cor):
    self.nome = nome
    self.cor = cor

fido = Cachorro("Fido", "marrom")
print(fido.pernas)
print(Cachorro.pernas)
```

__Resultado:__
```python
>>>
4
4
>>>
```

Os atributos da classe são compartilhados entre todas as instancias da classe.

Tentar acessar um atributo de uma instancia que não foi definido, causa um `AttributeError`. Isso tambem se aplica quando você acessa um metodo indefinido.

__Exemplo:__
```python
class Retangulo: 
  def __init__(self, largura, altura):
    self.largura = largura
    self.altura = altura

retangulo = Retangulo(7, 8)
print(retangulo.cor)
```

__Resultado:__
```python
>>>
AttributeError: 'Rectangle' object has no attribute 'color'
>>>
```

# [Herança](#índice)
A __herança__ fornece uma maneira de compartilhar funcionalidades entre classes.<br>Imagine varias classes, __Gato__, __Cachorro__, __Coelho__ e assim em diante. Embora diferenciem em alguns aspectos (apenas __Cachorro__ pode ter o metodo __latir__), podem ter algo em comum (todos tendo os atributos __cor__ e __nome__).<br>Essa similariedade pode ser expressada fazendo com que herdem de uma superclasse __Animal__, que contem as funcionalidades compartilhadas.<br>Para uma classe herdar de outra, coloque o nome da superclasse em parenteses depois do nome da classe.<br>__Exemplo:__
```python
class Animal: 
  def __init__(self, nome, cor):
    self.nome = nome
    self.cor = cor

class Gato(Animal):
  def ronronar(self):
    print("Purr...")
        
class Cachorro(Animal):
  def latir(self):
    print("Au! Au!")

fido = Cachorro("Fido", "marrom")
print(fido.cor)
fido.latir()
```

__Resultado:__
```python
>>>
marrom
Au! Au!
>>>
```

Uma classe que herda de outra classe é chamada de __subclasse__.<br>Uma classe que faz a herança é chamada de __superclasse__.<br>Se uma classe herda de outra com os mesmos atributos e metodos, ela os sobrescreve.
```python
class Lobo: 
  def __init__(self, nome, cor):
    self.nome = nome
    self.cor = cor

  def rosnar(self):
    print("Grr...")

class Cachorro(Lobo):
  def rosnar(self):
    print("Woof")
        
husky = Cachorro("Max", "cinza")
husky.rosnar()
```

__Resultado:__
```python
>>>
Woof
>>>
```

No exemplo acima, __Lobo__ é a superclasse, __Cachorro__ é a subclasse.

A herança tambem pode ser indireta. Uma classe pode herdar de outra e essa classe pode herdar de uma terceira classe.<br>__Exemplo:__
```python
class A:
  def metodo(self):
    print("Metodo de A")
    
class B(A):
  def outro_metodo(self):
    print("Metodo de B")
    
class C(B):
  def terceiro_metodo(self):
    print("Metodo de C")
    
c = C()
c.metodo()
c.outro_metodo()
c.terceiro_metodo()
```

__Resultado:__
```python
>>>
Metodo de A
Metodo de B
Metodo de C
>>>
```

Porém, herança circular não é possivel.

A função `super` é uma função util que tem relação com herança, se refere a classe mãe. Pode ser usada para encontrar um metodo com um certo nome em um objeto de uma superclasse.<br>__Exemplo:__
```python
class A:
  def spam(self):
    print(1)

class B(A):
  def spam(self):
    print(2)
    super().spam()
            
B().spam()
```

__Resultado:__
```python
>>>
2
1    
>>> 
```

`super().spam()` chama o metodo `spam` da superclasse.

# [Métodos mágicos e sobrecarga de operadores](#índice)

# [Ciclo de vida de um objeto](#índice)

# [Ocultando dados](#índice)

# [Métodos class e static](#índice)

# [Propriedades](#índice)

# [Um jogo simples](#índice)
