# Esta parte do curso está em progresso

Este curso é de propriedade do aplicativo [SoloLearn](https://play.google.com/store/apps/details?id=com.sololearn) e foi traduzido por [Ana Beatriz Augusto](https://www.linkedin.com/in/anabeatrizz) usando os recursos [Reverso Context](https://context.reverso.net/translation/) e [Google Tradutor](https://translate.google.com.br/?hl=pt-BR)

# Índice
- [Expressões regulares](#expressões-regulares)
  - [Encontre e substitua](#encontre-e-substitua)
- [Meta caracteres simples](#meta-caracteres-simples)
- [Classes de caracteres](#classes-de-caracteres)
- [Mais metacaracteres](#mais-metacaracteres)
  - [Chaves](#chaves)
- [Grupos](#grupos)
- [Sequencias especiais](#sequencias-especiais)
- [Extração de email](#extração-de-email)

# [Expressões regulares](#índice)
As __expressões regulares__  são ferramentas poderosas para vários tipos de manipulação de string.<br>São uma Linguagem de Domínio Especifico representadas como uma biblioteca na maioria das linguagens de programação modernas, não apenas Python.<br>São úteis para duas principais tarefas:<br>\- verificar se strings correspondem a um __padrão__ (por exemplo, se uma string tem o formato de um endereço de e-mail),<br>\- fazer substituições em uma string (como mudar todas as palavras Americanas para Britânicas).

Linguagens de Domínio Especifico são mini linguagens de programação altamente especializadas.<br>Expressões regulares são um exemplo popular e SQL (para manipulação de base de dados) é outra.<br>Linguagens Privadas de Domínio Especifico são frequentemente usadas para propósitos industriais específicos.

Expressões regulares em Python podem ser acessadas usando o modulo `re`, que faz parte de uma biblioteca padrão.<br>Depois de ter definido uma expressão regular, a função `re.match` pode ser usada para determinar se corresponde ao começo da string.<br>Se sim, `match` retorna um objeto representando a combinação, se não, retorna `None`.<br>Para evitar qualquer confusão enquanto se trabalha com expressões regulares, usaríamos strings puras como `r"expressao"`.<br>Strings puras não excluem nada, o que deixa o uso de expressões regulares mais fácil.

__Exemplo:__
```python
import re

padrao = r"spam"

if re.match(padrao, "spamspamspam"):
   print("Corresponde")
else:
   print("Não corresponde")
```

__Resultado:__
```
>>>  
Corresponde 
>>>
```

O exemplo acima avalia se o padrão "spam" corresponde à string e mostra "Corresponde" se sim.

Aqui o padrão é uma palavra simples, mas há vários caracteres que teriam significado especial quando usados em uma expressão regular.

Outras funções usadas para avaliar padrões são `re.search` e `re.findall`.<br>A função `re.search` encontra uma correspondência de um padrão em qualquer lugar da string.<br>A função  `re.findall` retorna uma lista de todas as substrings que correspondem ao padrão.

__Exemplo:__
```python
import re

padrao = r"spam"

if re.match(padrao, "eggspamsausagespam"):
   print("Corresponde")
else:
   print("Não corresponde")

if re.search(padrao, "eggspamsausagespam"):
   print("Corresponde")
else:
   print("Não corresponde")
    
print(re.findall(padrao, "eggspamsausagespam"))
```

__Resultado:__
```
>>>  
Não corresponde  
Corresponde  
['spam', 'spam']  
>>>
```

No exemplo acima, a função `match` não encontrou correspondências, pois ela avalia o começo da string.<br>A função `search` encontrou uma correspondência na string.

A função `re.finditer` faz o mesmo que `re.findall`, exceto que ela retorna um iterador, ao invés de uma lista.

A pesquisa de expressões regulares retorna um objeto com vários métodos que dão detalhes sobre eles.<br>Estes métodos incluem `group` que retorna a string correspondente, `start` e `end` que retornam as posições iniciais e finais da primeira correspondência e `span` que retorna as posições iniciais e finais da primeira correspondência como uma tupla. 

__Exemplo:__
```python
import re

padrao = r"pam"

correspondencia = re.search(padrao, "eggspamsausage")
if correspondencia:
   print(correspondencia.group())
   print(correspondencia.start())
   print(correspondencia.end())
   print(correspondencia.span())
```

__Resultado:__
```
>>>
pam
4
7
(4, 7)
>>>
```

### [Encontre e substitua](#índice)

Um dos mais importantes métodos do `re` que usa expressoes regulares é `sub`.

__Sintaxe:__<br>`re.sub(padrao, substituicao, string, contador=0)`

Este método substitui todas as ocorrências de `padrao` na string com `substituicao`, substituindo todas as ocorrências, a menos que `contador` seja fornecido. Este método retorna a string modificada.

__Exemplo:__
```python
import re

string = "Meu nome é David. Oi David."
padrao = r"David"
nova_string = re.sub(padrao, "Amy", string)
print(nova_string)
```

__Resultado:__
```
>>>  
Meu nome é Amy. Oi Amy.  
>>>
```

# [Meta caracteres simples](#índice)
Meta caracteres são o que fazem as expressões regulares mais poderosas do que os métodos normais de string. Te permitem criar expressões regulares para representar conceitos como "um ou mais repetições de vogal".

A existência de meta caracteres apresenta um problema caso você queira criar uma expressão regular (ou regex) que corresponde com um meta caractere literal como "$". Você pode fazer isso escapando os meta caracteres colocando uma __barra invertida__ na frente deles.<br>Porém, isso pode causar problemas, pois, barras invertidas também tem uma função de escapamento em strings normais do Python. Isso significa colocar três ou quatro barras invertidas em uma linha para fazer todo o escapamento.

Para evitar isso, você pode usar uma string pura, que é uma string normal com um "r" na frente. Vimos o uso de strings puras anteriormente.

A primeira meta caractere que iremos analisar é o ponto final.<br>Ele corresponde a __qualquer caractere__, que não seja uma nova linha.

__Exemplo:__
```python
import re

padrao = r"gr.y"

if re.match(padrao, "grey"):
   print("Correspondencia 1")

if re.match(padrao, "gray"):
   print("Correspondencia 2")

if re.match(padrao, "blue"):
   print("Correspondencia 3")
```

__Resultado:__
```
>>>  
Correspondencia 1  
Correspondencia 2  
>>>
```

Os próximos dois meta caracteres são __^__ e __$__.<br>Estes correspondem o começo e o fim de uma string, respectivamente.

__Exemplo:__
```python
import re

padrao = r"^gr.y$"

if re.match(padrao, "grey"):
   print("Correspondencia 1")

if re.match(padrao, "gray"):
   print("Correspondencia 2")

if re.match(padrao, "stingray"):
   print("Correspondencia 3")
```

__Resultado__
```
>>>  
Correspondencia 1  
Correspondencia 2  
>>>
```

O padrão `"^gr.y$"` significa que a string deve começar com __gr__, seguida de qualquer caractere, exceto uma nova linha e terminar com __y__.

# [Classes de caracteres](#índice)

# [Mais metacaracteres](#índice)
### [Chaves](#índice)

# [Grupos](#índice)

# [Sequencias especiais](#índice)

# [Extração de email](#índice)

Este curso é de propriedade do aplicativo [SoloLearn](https://play.google.com/store/apps/details?id=com.sololearn) e foi traduzido por [Ana Beatriz Augusto](https://www.linkedin.com/in/anabeatrizz) usando os recursos [Reverso Context](https://context.reverso.net/translation/) e [Google Tradutor](https://translate.google.com.br/?hl=pt-BR)
