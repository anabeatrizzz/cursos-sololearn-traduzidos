Este curso é de propriedade do aplicativo [SoloLearn](https://play.google.com/store/apps/details?id=com.sololearn) e foi traduzido por [Ana Beatriz Augusto](https://www.linkedin.com/in/anabeatrizz) usando os recursos [Reverso Context](https://context.reverso.net/translation/) e [Google Tradutor](https://translate.google.com.br/?hl=pt-BR)

# Índice
- [Expressões regulares](#expressões-regulares)
  - [Encontre e substitua](#encontre-e-substitua)
- [Meta caracteres simples](#meta-caracteres-simples)
- [Classes de caracteres](#classes-de-caracteres)
- [Mais metacaracteres](#mais-metacaracteres)
  - [Chaves](#chaves)
- [Grupos](#grupos)
- [Sequencias especiais](#sequencias-especiais)
- [Extração de e-mail](#extração-de-e-mail)

# [Expressões regulares](#índice)
As __expressões regulares__  são ferramentas poderosas para vários tipos de manipulação de string.<br>São uma Linguagem de Domínio Especifico representadas como uma biblioteca na maioria das linguagens de programação modernas, não apenas Python.<br>São úteis para duas principais tarefas:<br>\- verificar se strings correspondem a um __padrão__ (por exemplo, se uma string tem o formato de um endereço de e-mail),<br>\- fazer substituições em uma string (como mudar todas as palavras Americanas para Britânicas).

Linguagens de Domínio Especifico são mini linguagens de programação altamente especializadas.<br>Expressões regulares são um exemplo popular e SQL (para manipulação de base de dados) é outra.<br>Linguagens Privadas de Domínio Especifico são frequentemente usadas para propósitos industriais específicos.

Expressões regulares em Python podem ser acessadas usando o modulo `re`, que faz parte de uma biblioteca padrão.<br>Depois de ter definido uma expressão regular, a função `re.match` pode ser usada para determinar se corresponde ao começo da string.<br>Se sim, `match` retorna um objeto representando a combinação, se não, retorna `None`.<br>Para evitar qualquer confusão enquanto se trabalha com expressões regulares, usaríamos strings puras como `r"expressao"`.<br>Strings puras não excluem nada, o que deixa o uso de expressões regulares mais fácil.

__Exemplo:__
```python
import re

padrao = r"spam"

if re.match(padrao, "spamspamspam"):
   print("Corresponde")
else:
   print("Não corresponde")
```

__Resultado:__
```
>>>  
Corresponde 
>>>
```

O exemplo acima avalia se o padrão "spam" corresponde à string e mostra "Corresponde" se sim.

Aqui o padrão é uma palavra simples, mas há vários caracteres que teriam significado especial quando usados em uma expressão regular.

Outras funções usadas para avaliar padrões são `re.search` e `re.findall`.<br>A função `re.search` encontra uma correspondência de um padrão em qualquer lugar da string.<br>A função  `re.findall` retorna uma lista de todas as substrings que correspondem ao padrão.

__Exemplo:__
```python
import re

padrao = r"spam"

if re.match(padrao, "eggspamsausagespam"):
   print("Corresponde")
else:
   print("Não corresponde")

if re.search(padrao, "eggspamsausagespam"):
   print("Corresponde")
else:
   print("Não corresponde")
    
print(re.findall(padrao, "eggspamsausagespam"))
```

__Resultado:__
```
>>>  
Não corresponde  
Corresponde  
['spam', 'spam']  
>>>
```

No exemplo acima, a função `match` não encontrou correspondências, pois ela avalia o começo da string.<br>A função `search` encontrou uma correspondência na string.

A função `re.finditer` faz o mesmo que `re.findall`, exceto que ela retorna um iterador, ao invés de uma lista.

A pesquisa de expressões regulares retorna um objeto com vários métodos que dão detalhes sobre eles.<br>Estes métodos incluem `group` que retorna a string correspondente, `start` e `end` que retornam as posições iniciais e finais da primeira correspondência e `span` que retorna as posições iniciais e finais da primeira correspondência como uma tupla. 

__Exemplo:__
```python
import re

padrao = r"pam"

correspondencia = re.search(padrao, "eggspamsausage")
if correspondencia:
   print(correspondencia.group())
   print(correspondencia.start())
   print(correspondencia.end())
   print(correspondencia.span())
```

__Resultado:__
```
>>>
pam
4
7
(4, 7)
>>>
```

### [Encontre e substitua](#índice)

Um dos mais importantes métodos do `re` que usa expressoes regulares é `sub`.

__Sintaxe:__<br>`re.sub(padrao, substituicao, string, contador=0)`

Este método substitui todas as ocorrências de `padrao` na string com `substituicao`, substituindo todas as ocorrências, a menos que `contador` seja fornecido. Este método retorna a string modificada.

__Exemplo:__
```python
import re

string = "Meu nome é David. Oi David."
padrao = r"David"
nova_string = re.sub(padrao, "Amy", string)
print(nova_string)
```

__Resultado:__
```
>>>  
Meu nome é Amy. Oi Amy.  
>>>
```

# [Meta caracteres simples](#índice)
Meta caracteres são o que fazem as expressões regulares mais poderosas do que os métodos normais de string. Te permitem criar expressões regulares para representar conceitos como "um ou mais repetições de vogal".

A existência de meta caracteres apresenta um problema caso você queira criar uma expressão regular (ou regex) que corresponde com um meta caractere literal como "$". Você pode fazer isso escapando os meta caracteres colocando uma __barra invertida__ na frente deles.<br>Porém, isso pode causar problemas, pois, barras invertidas também tem uma função de escapamento em strings normais do Python. Isso significa colocar três ou quatro barras invertidas em uma linha para fazer todo o escapamento.

Para evitar isso, você pode usar uma string pura, que é uma string normal com um "r" na frente. Vimos o uso de strings puras anteriormente.

A primeira meta caractere que iremos analisar é o ponto final.<br>Ele corresponde a __qualquer caractere__, que não seja uma nova linha.

__Exemplo:__
```python
import re

padrao = r"gr.y"

if re.match(padrao, "grey"):
   print("Correspondencia 1")

if re.match(padrao, "gray"):
   print("Correspondencia 2")

if re.match(padrao, "blue"):
   print("Correspondencia 3")
```

__Resultado:__
```
>>>  
Correspondencia 1  
Correspondencia 2  
>>>
```

Os próximos dois meta caracteres são __^__ e __$__.<br>Estes correspondem o começo e o fim de uma string, respectivamente.

__Exemplo:__
```python
import re

padrao = r"^gr.y$"

if re.match(padrao, "grey"):
   print("Correspondencia 1")

if re.match(padrao, "gray"):
   print("Correspondencia 2")

if re.match(padrao, "stingray"):
   print("Correspondencia 3")
```

__Resultado__
```
>>>  
Correspondencia 1  
Correspondencia 2  
>>>
```

O padrão `"^gr.y$"` significa que a string deve começar com __gr__, seguida de qualquer caractere, exceto uma nova linha e terminar com __y__.

# [Classes de caracteres](#índice)
As classes de caracteres fornecem uma maneira de correspondência de apenas um caractere em um conjunto de caracteres.<br>Uma classe de caractere é criada quando se coloca os caracteres correspondentes entre __colchetes__.

__Exemplo:__
```python
import re

padrao = r"[aeiou]"

if re.search(padrao, "grey"):
   print("Correspondencia 1")

if re.search(padrao, "qwertyuiop"):
   print("Correspondencia 2")

if re.search(padrao, "rhythm myths"):
   print("Correspondencia 3")
```

__Resultado:__
```
>>>  
Correspondencia 1  
Correspondencia 2  
>>>
```

O padrão __[aeiou]__ na função search corresponde a todas as strings que contem qualquer um desses caracteres definidos.

Classes de caractere também podem corresponder a intervalos de caracteres.<br>Alguns exemplos:<br>A classe __[a-z]__ corresponde a qualquer caractere alfabético minusculo.<br>A classe __[G-P]__ corresponde a qualquer caractere maiúsculo de G a P.<br>A classe __[0-9]__ corresponde a qualquer digito.<br>Múltiplos intervalos podem ser incluídos em uma classe. Por exemplo, [A-Za-z] corresponde a uma letra em maiúsculo ou minusculo.

__Exemplo:__
```python
import re

padrao = r"[A-Z][A-Z][0-9]"

if re.search(padrao, "LS8"):
   print("Correspondencia 1")

if re.search(padrao, "E3"):
   print("Correspondencia 2")

if re.search(padrao, "1ab"):
   print("Correspondencia 3")
```

__Resultado:__
```
>>>
Correspondencia 1
>>>
```

O padrão no exemplo acima corresponde a strings que contem duas letras alfabéticas em maiúsculo seguidas por um digito.

Coloque um __^__ no começo de uma classe de caractere para __inverte-la__.<br>Isso faz com que a correspondência seja qualquer caractere, exceto aqueles incluídos.<br>Outras meta caracteres como __$__ e __.__ não tem significado dentro das classes de caractere.<br>O meta caractere __^__ não tem significado a menos que seja o primeiro caractere em uma classe.

__Exemplo:__
```python
import re

padrao = r"[^A-Z]"

if re.search(padrao, "this is all quiet"):
   print("Correspondencia 1")

if re.search(padrao, "AbCdEfG123"):
   print("Correspondencia 2")

if re.search(padrao, "THISISALLSHOUTING"):
   print("Correspondencia 3")
```

__Resultado:__
```
>>>
Correspondencia 1
Correspondencia 2
>>>
```

O padrão __[^A-Z]__ exclui strings em maiúsculo.<br>Note que o ^ deve estar dentro dos colchetes para inverter a classe de caractere.

# [Mais metacaracteres](#índice)
Outras meta caracteres são __*__, __+__, __?__, __{__ e __}__.<br>Estes especificam números de repetições.<br>O meta caractere __*__ significa "zero ou mais repetições de coisa anterior". Ele tenta corresponder a quantas repetições possíveis. A "coisa anterior" pode ser um caractere único, uma classe, ou um grupo caracteres em __parênteses__.

__Exemplo:__
```python
import re

padrao = r"egg(spam)*"

if re.match(padrao, "egg"):
   print("Correspondência 1")

if re.match(padrao, "eggspamspamegg"):
   print("Correspondência 2")

if re.match(padrao, "spam"):
   print("Correspondência 3")
```

__Resultado:__
```
>>>
Correspondência 1
Correspondência 2
>>>
```

O exemplo acima corresponde a strings que começam com "__egg__" seguidas de zero ou mais "__spam__"s

O meta caractere __+__ é muito similar ao __*__, exceto que ele significa "__uma__ ou mais repetições", o que é oposto a "zero ou mais repetições".

__Exemplo:__
```python
import re

padrao = r"g+"

if re.match(padrao, "g"):
   print("Correspondência 1")

if re.match(padrao, "gggggggggggggg"):
   print("Correspondência 2")

if re.match(padrao, "abc"):
   print("Correspondência 3")
```

__Resultado:__
```
>>>
Correspondência 1
Correspondência 2
>>>
```

Para resumir:<br>* corresponde a 0 ou mais ocorrências da expressão precedente.<br>+ corresponde a 1 ou mais ocorrências da expressão precedente.

O meta caractere __?__ significa "zero ou uma repetições".

__Exemplo:__
```python
import re

padrao = r"ice(-)?cream"

if re.match(padrao, "ice-cream"):
   print("Correspondência 1")

if re.match(padrao, "icecream"):
   print("Correspondência 2")

if re.match(padrao, "sausages"):
   print("Correspondência 3")

if re.match(padrao, "ice--ice"):
   print("Correspondência 4")
```

__Resultado:__
```
>>>
Correspondência 1
Correspondência 2
>>>
```
### [Chaves](#índice)
As chaves podem ser usadas para representar o número de repetições entre dois números.<br>A expressão regular __{x, y}__ significa "repetições de algo entre x e y".<br>Consequentemente __{0, 1}__ é o mesmo que __?__.<br>Se o primeiro número estiver faltando, é dito como se fosse zero. Se o segundo número estiver faltando, é dito como se fosse infinito.

__Exemplo:__
```python
import re

padrao = r"9{1,3}$"

if re.match(padrao, "9"):
   print("Correspondência 1")

if re.match(padrao, "999"):
   print("Correspondência 2")

if re.match(padrao, "9999"):
   print("Correspondência 3")
```

__Resultado:__
```
>>>
Correspondência 1
Correspondência 2
>>>
```

"9{1,3}$" correspondente a string que tem 1 a 3 noves.

# [Grupos](#índice)
Um grupo pode ser criado colocando-se parẽnteses ao redor de uma expressão regular.<br>Isso significa que um grupo pode ser dado como um argumento a meta caracteres como * e ?.

__Exemplo:__
```python
import re

padrao = r"egg(spam)*"

if re.match(padrao, "egg"):
   print("Correspondencia 1")

if re.match(padrao, "eggspamspamspamegg"):
   print("Correspondencia 2")

if re.match(padrao, "spam"):
   print("Correspondencia 3")
```

__(spam)__ representa um grupo no padrão usado como exemplo acima.

__Resultado:__
```
>>>  
Correspondencia 1  
Correspondencia 2  
>>>
```

O conteúdo de grupos em uma correspondência pode ser acessado usando a função `group`.<br>Chamar `group(0)` ou `group()` retorna a correspondência inteira.<br>Chamar `group(n)`, onde `n` é maior que 0, retorna o enésimo grupo da esquerda.<br>O método `groups()` retorna todos os grupos a partir do 1.

__Exemplo:__
```python
import re

padrao = r"a(bc)(de)(f(g)h)i"

correspondencia = re.match(padrao, "abcdefghijklmnop")
if correspondencia:
   print(match.group())
   print(match.group(0))
   print(match.group(1))
   print(match.group(2))
   print(match.groups())
```

__Resultado:__
```
>>>  
abcdefghi  
abcdefghi  
bc  
de  
('bc', 'de', 'fgh', 'g')  
>>>
```

Como podemos ver no exemplo acima, grupos podem ser aninhados.

Há vários tipos de grupos especiais.<br>Os dois uteis são os __grupos nomeados__ e os __grupos não-capturados__.<br>__Grupos nomeados__ têm o formato __(?P\<nome>...)__, onde __nome__ é o nome do grupo e __...__ é o conteúdo. Podem se comportar da mesma maneira que grupos normais, exceto que podem ser acessados por __group(nome)__ além de seu número.<br>__Grupos não-capturados__ têm o formato __(?:...)__. Não são acessíveis pelo método `group`, então eles podem ser adicionados a uma expressão regular existente sem interferirem nos nùmeros.

__Exemplo:__
```python
import re

padrao = r"(?P<first>abc)(?:def)(ghi)"

correspondencia = re.match(padrao, "abcdefghi")
if correspondencia:
   print(match.group("first"))
   print(match.groups())
```

__Resultado:__
```
>>>  
abc  
('abc', 'ghi')  
>>>
```

Outro meta caractere importante é o __|__.<br>Ele significa "ou", então __vermelho|azul__ corresponde a "vermelho" ou "azul".

__Exemplo:__
```python
import re

padrao = r"gr(a|e)y"

correspondencia = re.correspondencia(padrao, "gray")
if correspondencia:
   print ("Correspondencia 1")

correspondencia = re.correspondencia(padrao, "grey")
if correspondencia:
   print ("Correspondencia 2")    

correspondencia = re.correspondencia(padrao, "griy")
if correspondencia:
    print ("Correspondencia 3")
```

__Resultado:__
```
>>>  
Correspondencia 1  
Correspondencia 2  
>>>
```

# [Sequencias especiais](#índice)
Há varias sequencias especiais que você pode usar nas expressões regulares. Elas são escritas com uma barra invertida seguida por outro caractere.<br>Uma sequencia especial útil é uma barra invertida e um numero entre 1 e 99, ex: \1 ou \17. Isso corresponde a expressão do grupo deste numero.

__Exemplo:__
```python
import re

padrao = r"(.+) \1"

correspondencia = re.match(padrao, "word word")
if correspondencia:
   print ("Correspondencia 1")

correspondencia = re.match(padrao, "?! ?!")
if correspondencia:
   print ("Correspondencia 2")    

correspondencia = re.match(padrao, "abc cde")
if correspondencia:
   print ("Correspondencia 3")
```

__Resultado:__
```
>>>  
Correspondencia 1  
Correspondencia 2  
>>>
```

Note que __"(.+) \1"__ não é o mesmo que __"(.+) (.+)"__ pois, __\1__ se refere a subexpressão do primeiro grupo, que é a própria expressão correspondente e não o padrão regex.

Outras sequencias especiais são __\d__, __\s__ e __\w__.<br>Estas correspondem a __dígitos__, __espaços em branco__ e __caracteres de palavra__ respectivamente.<br>No modo ASCII elas são equivalentes a [0-9], [ \t\n\r\f\v] e [a-zA-Z0-9_].<br>No modo Unicode elas correspondem a outros caracteres também. Por exemplo, __\w__ corresponde a letras com acento.<br>Versões destas sequencias especiais em maiúsculo - __\D__, __\S__ e __\W__ - significam que são opostas as versões em letras minusculas. Por exemplo, __\D__ corresponde a tudo que não é um digito.

__Exemplo:__
```python
import re

padrao = r"(\D+\d)"

correspondencia = re.match(padrao, "Hi 999!")

if correspondencia:
   print("Correspondencia 1")

correspondencia = re.match(padrao, "1, 23, 456!")
if correspondencia:
   print("Correspondencia 2")

correspondencia = re.match(padrao, " ! $?")
if correspondencia:
    print("Correspondencia 3")
```

__Resultado:__
```
>>>  
Correspondencia 1  
>>>
```

__(\D+\d)__ corresponde a um ou mais não-dígitos seguidos por um digito.

Sequencias especiais adicionais são __\A__, __\Z__ e __\b__.<br>As sequencias __\A__ e __\Z__ correspondem ao começo e ao final de uma string, respectivamente.<br>A sequencia __\b__ corresponde a string vazia entre caracteres __\w__ e __\W__, ou caracteres __\w__ e o começo ou fim da string. De forma informal, representa o limite entre palavras.<br>A sequencia __\B__ corresponde a string vazia em qualquer outro lugar.

__Exemplo:__
```python
import re

padrao = r"\b(cat)\b"

correspondencia = re.search(padrao, "The cat sat!")
if correspondencia:
   print ("Correspondencia 1")

correspondencia = re.search(padrao, "We s>cat<tered?")
if correspondencia:
   print ("Correspondencia 2")

correspondencia = re.search(padrao, "We scattered.")
if correspondencia:
   print ("Correspondencia 3")
```

__Resultado:__
```
>>>
Correspondencia 1
Correspondencia 2
>>>
```

__"\b(gato)\b"__ basicamente corresponde a palavra __"gato"__ cercada por limites de palavra.

# [Extração de e-mail](#índice)
Para demonstrar uma amostra de uso das expressões regulares, vamos criar um programa para extrair endereços de e-mails de uma string.<br>Suponha que temos um texto que contem um endereço de e-mail:
```python
string = "Por favor contate info@sololearn.com para assistencia"
```

Nossa meta é extrair a substring "info@sololearn.com".<br>Um endereço de e-mail básico consiste de uma palavra e pode incluir pontos ou hifens. Isso é seguido pelo sinal @ e o nome do domínio (o nome, um ponto e o sufixo do nome do domínio).<br>Isso é o básico para construir nossa expressão regular.
```python
padrao = r"([\w\.-]+)@([\w\.-]+)(\.[\w\.]+)"
```

__[\w\.-]+__ corresponde a uma ou mais caracteres de palavra, ponto ou hífen.<br>A regex acima diz que uma string deve conter uma palavra (com pontos e hifens permitidos), seguida pelo sinal de @, outra palavra similar e então um ponto ou outra palavra.

Nossa regex contem três grupos:<br>1 - a primeira parte do endereço de e-mail.<br>2 - o nome do domínio sem o sufixo.<br>3 - o sufixo do domínio.

Juntando tudo isso:
```python
import re

padrao = r"([\w\.-]+)@([\w\.-]+)(\.[\w\.]+)"

string = "Por favor contate info@sololearn.com para assistencia"

correspondencia = re.search(padrao, string)
if correspondencia:
   print(match.group())
```

__Resultado:__
```
>>>  
info@sololearn.com  
>>>
```

Caso a string contenha múltiplos endereços de e-mail, podemos usar o método `re.findall` ao invés de `re.search` para extrair todos os endereços de e-mail.

A regex neste exemplo serve apenas para demonstração.<br>Uma regex muita mais complexa é requerida para completamente validar um endereço de e-mail.

Este curso é de propriedade do aplicativo [SoloLearn](https://play.google.com/store/apps/details?id=com.sololearn) e foi traduzido por [Ana Beatriz Augusto](https://www.linkedin.com/in/anabeatrizz) usando os recursos [Reverso Context](https://context.reverso.net/translation/) e [Google Tradutor](https://translate.google.com.br/?hl=pt-BR)
