# Esta parte do curso está em progresso

Este curso é de propriedade do aplicativo [SoloLearn](https://play.google.com/store/apps/details?id=com.sololearn) e foi traduzido por [Ana Beatriz Augusto](https://www.linkedin.com/in/anabeatrizz) usando os recursos [Reverso Context](https://context.reverso.net/translation/) e [Google Tradutor](https://translate.google.com.br/?hl=pt-BR)

# Índice
- [Ocultando dados](#ocultando-dados)
- [Métodos class e static](#métodos-class-e-static)
   - [Métodos de classes](#métodos-de-classes)
- [Propriedades](#propriedades)
- [Um jogo simples](#um-jogo-simples)

# [Ocultando dados](#índice)
Uma parte chave da programação orientada a objetos é o __encapsulamento__, que envolve empacotar variaveis relacionadas e funções em um objeto de facil uso - uma instancia de uma classe.<br>Um conceito relacionado é o __ocultamento de dados__, que declara que os detalhes de implementação de uma classe devem ficar ocultos e que uma interface padrão seja apresentada para aqueles que querem usar a classe.<br>Em outras linguagens de programação, isso geralmente é feito com metodos e atributos privados, que bloqueiam acesso externo a certos metodos e atributos em uma classe.

A filosofia do Python é um pouco diferente. Frequentemente é declarada como __"todos nós consentimos adultos aqui"__, significando que você não deveria colocar restrições arbitrarias quando acessa partes de uma classe. Consequentemente, não há maneiras de fazer com que um metodo ou atributo seja estritamente privado.

Porém, há maneiras de desencorajar pessoas para que não acessem partes de uma classe, declarar como sendo um detalhe em implementação e que deve ser usado sob seu proprio risco, por exemplo.

Metodos e atributos privados de maneira fraca têm um __unico underline__ no começo.<br>Isso diz que são privados e não devem ser usados por codigo externo. Porém, é apenas uma convenção e não faz com que um codigo externo não acesse eles.<br>Seu unico efeito é que `from nome_do_modulo import *` não irá importar variaveis que começam com um unico underline.<br>__Exemplo:__
```python
class Queue:
  def __init__(self, conteudo):
    self._listaoculta = list(conteudo)

  def push(self, valor):
    self._listaoculta.insert(0, valor)
   
  def pop(self):
    return self._listaoculta.pop(-1)

  def __repr__(self):
    return "Queue({})".format(self._listaoculta)

queue = Queue([1, 2, 3])
print(queue)
queue.push(0)
print(queue)
queue.pop()
print(queue)
print(queue._listaoculta)
```

__Resultado:__
```python
>>>
Queue([1, 2, 3])
Queue([0, 1, 2, 3])
Queue([0, 1, 2])
[0, 1, 2]
>>>
```

No codigo acima, o atributo __\_listaoculta__ está marcado como privado, mas ainda pode ser acessado fora do codigo.<br>O metodo magico `__repr__` é usado para representação de string da instancia.

Metodos e atributos privados fortemente tem __dois underlines__ no começo de seus nomes. Isso causa uma deformação em seus nomes, o que significa que não podem ser acessados fora da classe.<br>O proposito disso não é fazer com que fiquem em privado, mas evitar bugs se há subclasses que tem metodos ou atributos com os mesmos nomes.<br>Metodos com nomes deformados ainda podem ser acessados externamente, mas por um nome diferente. O metodo `__metodoprivado` da classe __Spam__ pode ser acessado externamente com `_Spam__metodoprivado`.<br>__Exemplo:__
```python
class Spam:
  __egg = 7
  def mostre_egg(self):
    print(self.__egg)

s = Spam()
s.mostre_egg()
print(s._Spam__egg)
print(s.__egg)
```

__Resultado:__
```python
>>>
7
7
AttributeError: 'Spam' object has no attribute '__egg'
>>>
```

Basicamente, o Python protege estes membros mudando internamente o nome para incluir o nome da classe.

# [Métodos class e static](#índice)
### [Métodos de classes](#índice)
Os métodos de objetos que vimos até aqui são chamados por uma instancia de uma classe, que é então passada ao parametro `self` do método.<br>Métodos de classes são diferentes - são chamados por uma classe, que é passada ao parametro `cls` do metodo.<br>Um uso comum desses metodos de fabrica, que instanciam uma instancia de uma classe, usam parametros diferentes daqueles que geralmente são passados a classe construtor.<br>Métodos de classes são maracados com um decorador `classmethod`.<br>__Exemplo:__
```python
class Retangulo:
  def __init__(self, largura, altura):
    self.largura = largura
    self.altura = altura

  def calcular_area(self):
    return self.largura * self.altura

  @classmethod
  def novo_quadrado(cls, lado):
    return cls(lado, lado)

quadrado = Retangulo.novo_quadrado(5)
print(quadrado.calcular_area())
```

__Resultado:__
```python
>>>
25
>>>
```

`novo_quadrado` é um metodo de classe e é chamdo na classe, ao invés de ser chamado em uma instancia da classe. Retorna um novo objeto da classe `cls`.

Tecnicamente, os parametros `self`e `cls` são apenas convenções; podem ser mudados para outra coisa. Porém, são universamente seguidos, então é inteligente continuar usando eles.

# [Propriedades](#índice)
__Propriedades__ fornecem uma maneira de customizar o acesso a atributos de instâncias.<br>São criadas com o decorador `property` acima de um método, significando que quando o atributo da instância é acessado, o método irá ser chamado em seu lugar.<br>Um uso comum das propriedades é fazer com que um atributo seja apenas para __leitura__.<br>__Exemplo:__

```python
class Pizza:
  def __init__(self, sabores):
    self.sabores = sabores
    
  @property
  def abacaxi_permitido(self):
    return False

pizza = Pizza(["queijo", "tomate"])
print(pizza.abacaxi_permitido)
pizza.abacaxi_permitido = True
```

__Resultado:__

```python
>>>
False

AttributeError: can't set attribute
>>>
```

Propriedades também podem ser definidas indicando funções __setters__ e __getters__.<br>A função `setter` define o valor da propriedade correspondente.<br>A função `getter` pega esse valor.<br>Para definir um `setter`, você precisa usar um decorador com o mesmo nome da propriedade, seguido por um ponto e a palavra reservada `setter`.<br>O mesmo se aplica na definição de funções `getter`.<br>__Exemplo:__

```python
class Pizza:
  def __init__(self, sabores):
    self.sabores = sabores
    self._abacaxi_permitido = False

  @property
  def abacaxi_permitido(self):
    return self._abacaxi_permitido

  @abacaxi_permitido.setter
  def abacaxi_permitido(self, valor):
    if valor:
      senha = input("Digite a senha: ")
      if senha == "P3ixeE$p4d4!":
        self._abacaxi_permitido = valor
      else:
        raise ValueError("Alerta! Intruso!")

pizza = Pizza(["queijo", "tomate"])
print(pizza.abacaxi_permitido)
pizza.abacaxi_permitido = True
print(pizza.abacaxi_permitido)
```
__Resultado:__

```python
>>>
False
Digite a senha: P3ixeE$p4d4!
True
```

# [Um jogo simples](#índice)
